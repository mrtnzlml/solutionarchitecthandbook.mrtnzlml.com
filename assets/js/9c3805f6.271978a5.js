"use strict";(self.webpackChunkuniversity=self.webpackChunkuniversity||[]).push([[9743],{7386:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>d});var a=n(8942),l=n(4848),o=n(8453),s=n(6298);const i={title:"Multiple data matching results",slug:"multiple-data-matching-results",authors:["mrtnzlml","VaclavRut"],tags:["master-data-hub","rossum-formulas"]},r=void 0,u={authorsImageUrls:[void 0,void 0]},d=[];function c(e){const t={a:"a",code:"code",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsxs)(t.p,{children:['Data matching (Master Data Hub; MDH) results are by default returned into an "enum" field in Rossum (also known as "Options" field). Enum field allows to select only one of the values returned (it behaves as a regular ',(0,l.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/select",children:"HTML select element"})," with options). What if you need to select multiple values, however?"]}),"\n",(0,l.jsxs)(t.p,{children:["The solution is to return all values into a ",(0,l.jsx)(t.strong,{children:"hidden"})," enum field and later process the data using a simple serverless function. In our example, the hidden field is ",(0,l.jsx)(t.code,{children:"order_id_match"}),":"]}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-python",children:'from txscript import TxScript, default_to, substitute\n\n\ndef rossum_hook_request_handler(payload):\n    x = TxScript.from_payload(payload)\n\n    # Do not recalculate if the input data has not changed\n    # (add more fields depending on the input into your MDH query):\n    recalculate_hash = f"{x.field.order_id}__{x.field.grn_id}"\n    if x.field.recalculate_hash == recalculate_hash:\n        return x.hook_response()\n\n    # Get all valid enum options (result of the MDH query):\n    order_line_options = default_to(x.field.order_id_match.attr.options, [])\n    valid_options = [\n        opt for opt in order_line_options if opt.value\n    ]\n\n    # Clear existing multivalue table:\n    x.field.order_id_lines = []\n\n    # Create new multivalue table:\n    new_lines = []\n    for option in valid_options:\n        new_lines.append({\n            "order__id": option.value\n            # What about other columns? Keep reading. :)\n        })\n\n    # Insert new values into the multivalue table:\n    x.field.order_id_lines = new_lines\n    x.field.recalculate_hash = recalculate_hash\n\n    return x.hook_response()\n'})}),"\n",(0,l.jsx)(t.p,{children:"The function does the following:"}),"\n",(0,l.jsxs)(t.ol,{children:["\n",(0,l.jsxs)(t.li,{children:["Get all valid options from the ",(0,l.jsx)(t.code,{children:"order_id_match"})," enum field."]}),"\n",(0,l.jsxs)(t.li,{children:["Clear the existing ",(0,l.jsx)(t.code,{children:"order_id_lines"})," table (our destination)."]}),"\n",(0,l.jsxs)(t.li,{children:["Insert the enum values into the ",(0,l.jsx)(t.code,{children:"order_id_lines"})," destination table."]}),"\n"]}),"\n",(0,l.jsxs)(t.p,{children:["Additionally, it takes care of recalculating the table lazily so users can update the final table manually if needed (see the ",(0,l.jsx)(t.code,{children:"recalculate_hash"})," field)."]}),"\n",(0,l.jsx)(t.p,{children:"This way, all data matching results were populated into multivalue table despite the data matching supporting only enum fields."}),"\n",(0,l.jsx)(t.p,{children:"Note that it might be a good idea to lazily load additional values in the table. In real-world solution, the chain of hooks would look like this:"}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-text",children:".---------.      .--------------------------.      .---------.\n|  MDH 1  | ---\x3e |  Custom hook from above  | ---\x3e |  MDH 2  |\n`---------`      `--------------------------`      `---------`\n"})}),"\n",(0,l.jsx)(t.p,{children:"This way, we can distribute only row IDs from the first MDH extension and load the actual data in the second MDH extension. Alternatively, we could populate all the data in the first MDH hook. That is however a bit laborious when there are many columns to populate and distribute."}),"\n",(0,l.jsx)(s.A,{question:"Can master data hub extension return values to a string field?",answers:[{text:"Yes, MDH can return values into any preconfigured field"},{text:"No, only enum fields are supported",isCorrect:!0}],children:(0,l.jsxs)(t.p,{children:["The only field type that Master Data Hub (MDH) extension supports are ",(0,l.jsx)(t.code,{children:"enum"})," fields. Enum fields limit the section to only one specific value. However, we can still access all the values (options) using the ",(0,l.jsx)(t.code,{children:"x.field.order_id_match.attr.options"})," code which can later be distributed into a multivalue table."]})})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,l.jsx)(t,{...e,children:(0,l.jsx)(c,{...e})}):c(e)}},6298:(e,t,n)=>{n.d(t,{A:()=>s});var a=n(6540);const l={container:"container_dm9A",header:"header_J8KY",question:"question_Y9ba",button:"button_lYqq",correctButton:"correctButton_sT4o",incorrectButton:"incorrectButton_zSxd",explanation:"explanation_qYnh",explanationHeader:"explanationHeader_JvNX",buttonContainer:"buttonContainer_mbUi",disabledButton:"disabledButton_iQXr"};var o=n(4848);function s(e){let{question:t,answers:n,children:s}=e;const[i,r]=(0,a.useState)(!1),[u,d]=(0,a.useState)(null),c=e=>{const t=[l.button];return i&&(e.isCorrect?t.push(l.correctButton):u===e?t.push(l.incorrectButton):t.push(l.disabledButton)),t.join(" ")};return(0,o.jsxs)("div",{className:l.container,children:[(0,o.jsx)("h3",{className:l.header,children:"Test Your Knowledge"}),(0,o.jsx)("p",{className:l.question,children:t}),(0,o.jsx)("div",{className:l.buttonContainer,children:n&&n.map(((e,t)=>(0,o.jsx)("button",{className:c(e),onClick:()=>(e=>{d(e),r(!0)})(e),disabled:i,children:e.text},t)))}),i&&(0,o.jsxs)("div",{className:l.explanation,children:[(0,o.jsx)("p",{className:l.explanationHeader,children:"Explanation"}),(0,o.jsx)("p",{children:s})]})]})}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>i});var a=n(6540);const l={},o=a.createContext(l);function s(e){const t=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:s(e.components),a.createElement(o.Provider,{value:t},e.children)}},8942:e=>{e.exports=JSON.parse('{"permalink":"/cookbook/multiple-data-matching-results","source":"@site/cookbook/2025-08-14-multiple-data-matching-results.md","title":"Multiple data matching results","description":"Data matching (Master Data Hub; MDH) results are by default returned into an \\"enum\\" field in Rossum (also known as \\"Options\\" field). Enum field allows to select only one of the values returned (it behaves as a regular HTML select element with options). What if you need to select multiple values, however?","date":"2025-08-14T00:00:00.000Z","tags":[{"inline":false,"label":"master-data-hub","permalink":"/cookbook/tags/master-data-hub"},{"inline":false,"label":"rossum-formulas","permalink":"/cookbook/tags/rossum-formulas"}],"hasTruncateMarker":true,"authors":[{"name":"Martin Zl\xe1mal","title":"Solution Architect","url":"https://github.com/mrtnzlml","imageURL":"https://github.com/mrtnzlml.png","key":"mrtnzlml","page":null},{"name":"V\xe1clav R\u016ft","title":"Solution Architect","url":"https://github.com/VaclavRut","imageURL":"https://github.com/VaclavRut.png","key":"VaclavRut","page":null}],"frontMatter":{"title":"Multiple data matching results","slug":"multiple-data-matching-results","authors":["mrtnzlml","VaclavRut"],"tags":["master-data-hub","rossum-formulas"]},"unlisted":false,"prevItem":{"title":"3 things you need to know about Reasoning Fields","permalink":"/cookbook/three-things-you-need-to-know-about-reasoning-fields"}}')}}]);