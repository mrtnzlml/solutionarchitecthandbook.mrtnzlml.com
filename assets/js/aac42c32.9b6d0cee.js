"use strict";(self.webpackChunkuniversity=self.webpackChunkuniversity||[]).push([[1278],{6132:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"three-things-you-need-to-know-about-reasoning-fields","metadata":{"permalink":"/cookbook/three-things-you-need-to-know-about-reasoning-fields","source":"@site/cookbook/2025-08-28-three-things-you-need-to-know-about-reasoning-fields.md","title":"3 things you need to know about Reasoning Fields","description":"Rossum.ai recently introduced a new field type","date":"2025-08-28T00:00:00.000Z","tags":[{"inline":true,"label":"reasoning-fields","permalink":"/cookbook/tags/reasoning-fields"}],"hasTruncateMarker":true,"authors":[{"name":"Martin Zl\xe1mal","title":"Solution Architect","url":"https://github.com/mrtnzlml","imageURL":"https://github.com/mrtnzlml.png","key":"mrtnzlml","page":null}],"frontMatter":{"title":"3 things you need to know about Reasoning Fields","slug":"three-things-you-need-to-know-about-reasoning-fields","authors":["mrtnzlml"],"tags":["reasoning-fields"]},"unlisted":false,"nextItem":{"title":"Multiple data matching results","permalink":"/cookbook/multiple-data-matching-results"}},"content":"import QuizComponent from \'@site/src/components/QuizComponent\';\\n\\nRossum.ai recently introduced a new field type: **[Reasoning Fields](https://knowledge-base.rossum.ai/docs/reasoning-fields)** (inline LLM fields). Here is all you need to know about them from a Solution Architect:\\n\\n1. Reasoning Fields are designed to output \\"single value\\" predictions. It\'s better to have **many specialized fields** than one that solves many problems simultaneously. Parsing address? Create one Reasoning Field per address chunk (as opposed to having one fields that resolves all the chunks at once).\\n1. Reasoning Fields **remember previous predictions** and manual changes (rather aggressively!). Same inputs are likely to return the same output even when the prompt or the underlying model changes. Currently, the best way to overwrite this is by introducing a \\"cache buster\\" field.\\n1. Reasoning Fields are LLM-based. Naturally, like any other LLM, they are not a good fit for tasks requiring **accuracy** or **reproducibility**. While reproducibility is solved by the caching mentioned above, accuracy is still a problem. Favor [Formula Fields](https://knowledge-base.rossum.ai/docs/formula-fields-in-rossum) for deterministic outputs where possible (such as mathematical calculations).\\n\\n\x3c!-- truncate --\x3e\\n\\nOK, so how do you use Reasoning Fields? In your queue settings, add a new field of type \\"Reasoning\\" and configure it as you like. For example, here is a prompt that determines the country code from the input address (`sender_address`):\\n\\n```text\\nPlease follow these instructions precisely.\\n\\n### **1. General Instructions**\\n\\nProvide a single, three-letter, uppercase **ISO 3166-1 alpha-3** country code for the provided address string. The response must contain only this code, with no additional text, explanation, or punctuation.\\n\\n### **2. Field Instructions and Logic**\\n\\n- **`sender_address`**: The input is a string representing a physical address.\\n- **Logic**:\\n    - Identify the country from the `sender_address`.\\n    - If the country is explicitly mentioned (e.g., \\"USA\\", \\"United Kingdom\\"), use that to determine the alpha-3 code.\\n    - If the country is missing, infer the country from contextual clues such as the city, postal code, or regional language conventions.\\n    - **Exclude/Ignore**: Do not consider the name of the street or the building number for country identification.\\n    - If, after all attempts at inference, the country remains ambiguous or unidentifiable, return the fallback code.\\n\\n### **3. Fallback and Output Format**\\n\\n- The output must be exactly three uppercase letters.\\n- **`output_format`**: `[ISO 3166-1 alpha-3 code]`\\n- If the country cannot be determined, the output must be **\\"UNK\\"** (Unknown).\\n\\n### **4. Examples**\\n\\n| Input Address | Output |\\n| :--- | :--- |\\n| 1600 Amphitheatre Parkway, Mountain View, CA 94043, USA | USA |\\n| 10 Downing Street, London SW1A 2AA | GBR |\\n| K\u0159i\u017e\xedkova 148/34, 186 00 Karl\xedn, Czech Republic | CZE |\\n```\\n\\nProtip: do not rely on the model\'s output to be correct, always verify it if possible. For example, the above prompt should clearly return a three-letter code, so you can write a validation rule that makes sure that the output conforms to the specification (and the ISO code actually exists). This way you make sure that the user-confirmed data is always correct. In return the future predictions will be more accurate.\\n\\n<QuizComponent\\nquestion=\\"Which LLM API powers Reasoning Fields?\\"\\nanswers={[\\n{ text: \'Anthropic (Claude)\' },\\n{ text: \'ChatGPT\' },\\n{ text: \'Gemini PRO\' },\\n{ text: \'Grok\' },\\n{ text: \'In-house LLM\', isCorrect: true }\\n]}>\\nReasoning Fields are powered by an in-house LLM model that is self-hosted within the Rossum infrastructure, so it does not connect with any external source outside of Rossum\'s walls.\\n</QuizComponent>\\n\\nNote that Reasoning Fields are still in beta and are subject to change. Get in touch with your Rossum representative if you have any questions or concerns."},{"id":"multiple-data-matching-results","metadata":{"permalink":"/cookbook/multiple-data-matching-results","source":"@site/cookbook/2025-08-14-multiple-data-matching-results.md","title":"Multiple data matching results","description":"Data matching (Master Data Hub; MDH) results are by default returned into an \\"enum\\" field in Rossum (also known as \\"Options\\" field). Enum field allows to select only one of the values returned (it behaves as a regular HTML select element with options). What if you need to select multiple values, however?","date":"2025-08-14T00:00:00.000Z","tags":[{"inline":false,"label":"master-data-hub","permalink":"/cookbook/tags/master-data-hub"},{"inline":false,"label":"rossum-formulas","permalink":"/cookbook/tags/rossum-formulas"}],"hasTruncateMarker":true,"authors":[{"name":"Martin Zl\xe1mal","title":"Solution Architect","url":"https://github.com/mrtnzlml","imageURL":"https://github.com/mrtnzlml.png","key":"mrtnzlml","page":null},{"name":"V\xe1clav R\u016ft","title":"Solution Architect","url":"https://github.com/VaclavRut","imageURL":"https://github.com/VaclavRut.png","key":"VaclavRut","page":null}],"frontMatter":{"title":"Multiple data matching results","slug":"multiple-data-matching-results","authors":["mrtnzlml","VaclavRut"],"tags":["master-data-hub","rossum-formulas"]},"unlisted":false,"prevItem":{"title":"3 things you need to know about Reasoning Fields","permalink":"/cookbook/three-things-you-need-to-know-about-reasoning-fields"}},"content":"import QuizComponent from \'@site/src/components/QuizComponent\';\\n\\nData matching (Master Data Hub; MDH) results are by default returned into an \\"enum\\" field in Rossum (also known as \\"Options\\" field). Enum field allows to select only one of the values returned (it behaves as a regular [HTML select element](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/select) with options). What if you need to select multiple values, however?\\n\\n\x3c!-- truncate --\x3e\\n\\nThe solution is to return all values into a **hidden** enum field and later process the data using a simple serverless function. In our example, the hidden field is `order_id_match`:\\n\\n```python\\nfrom txscript import TxScript, default_to, substitute\\n\\n\\ndef rossum_hook_request_handler(payload):\\n    x = TxScript.from_payload(payload)\\n\\n    # Do not recalculate if the input data has not changed\\n    # (add more fields depending on the input into your MDH query):\\n    recalculate_hash = f\\"{x.field.order_id}__{x.field.grn_id}\\"\\n    if x.field.recalculate_hash == recalculate_hash:\\n        return x.hook_response()\\n\\n    # Get all valid enum options (result of the MDH query):\\n    order_line_options = default_to(x.field.order_id_match.attr.options, [])\\n    valid_options = [\\n        opt for opt in order_line_options if opt.value\\n    ]\\n\\n    # Clear existing multivalue table:\\n    x.field.order_id_lines = []\\n\\n    # Create new multivalue table:\\n    new_lines = []\\n    for option in valid_options:\\n        new_lines.append({\\n            \\"order__id\\": option.value\\n            # What about other columns? Keep reading. :)\\n        })\\n\\n    # Insert new values into the multivalue table:\\n    x.field.order_id_lines = new_lines\\n    x.field.recalculate_hash = recalculate_hash\\n\\n    return x.hook_response()\\n```\\n\\nThe function does the following:\\n\\n1. Get all valid options from the `order_id_match` enum field.\\n2. Clear the existing `order_id_lines` table (our destination).\\n3. Insert the enum values into the `order_id_lines` destination table.\\n\\nAdditionally, it takes care of recalculating the table lazily so users can update the final table manually if needed (see the `recalculate_hash` field).\\n\\nThis way, all data matching results were populated into multivalue table despite the data matching supporting only enum fields.\\n\\nNote that it might be a good idea to lazily load additional values in the table. In real-world solution, the chain of hooks would look like this:\\n\\n```text\\n.---------.      .--------------------------.      .---------.\\n|  MDH 1  | ---\x3e |  Custom hook from above  | ---\x3e |  MDH 2  |\\n`---------`      `--------------------------`      `---------`\\n```\\n\\nThis way, we can distribute only row IDs from the first MDH extension and load the actual data in the second MDH extension. Alternatively, we could populate all the data in the first MDH hook. That is however a bit laborious when there are many columns to populate and distribute.\\n\\n<QuizComponent\\nquestion=\\"Can master data hub extension return values to a string field?\\"\\nanswers={[\\n{ text: \'Yes, MDH can return values into any preconfigured field\' },\\n{ text: \'No, only enum fields are supported\', isCorrect: true }\\n]}>\\nThe only field type that Master Data Hub (MDH) extension supports are `enum` fields. Enum fields limit the section to only one specific value. However, we can still access all the values (options) using the `x.field.order_id_match.attr.options` code which can later be distributed into a multivalue table.\\n</QuizComponent>"}]}}')}}]);